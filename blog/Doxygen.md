---
slug: Doxygen
title: Doxygen
authors:
  name: Newbie
  title:  Team Newbie
tags: [hola, docusaurus]
---

## C/C++ 编码规范

### 缩进：

* 每一级缩进4个空格字符

* 嵌套命名空间无需缩进

  

### 代码行：

* 一行代码一件事

* if、for、while、do各占一行

* 尽量定义变量时初始化

  

### 注释：

* 行间注释：注释语句不与程序源码出现在同一行，主要用于文件版权和版本声明，类、结构体、枚举、联合等数据结构的声明描述，以及接口函数的功能描述。

* 行内注释：注释语句处于程序源码同行末尾处，主要用于宏定义、常量、成员变量、全局变量、局部变量的声明描述。

* 满足Doxygen指令要求

  

### 类的版式：

* 采用以行为中心：将 public 类型的函数写在前面，而将 private 类型的数据写在后面，重点关注的是类应该对外提供什么样的接口

  

### 文件命名：

* C/C++源程序通常包含2种类型的代码文件：

  用于保存程序声明（declaration）的头文件（header file）

  用于保存程序实现（implementation）的源文件（source file）

* C/C++程序的头文件以“.h/.hpp”为文件后缀，C/C++源文件以“.c/.cpp”为文件后缀
* 标准头文件和源文件遵循大驼峰法命名
* 接口定义头文件，文件名首字母为 “I”，表征 Interface  之意，后续部分仍遵循大驼峰法命名
* 基类实现类的头文件和源文件，文件名尾字母为 “I”，表征 Implementation  之意，其他部分仍遵循大驼峰法命名



### 头文件结构：

* 为了防止头文件被重复引用，应当用ifndef/define/endif 结构产生预处理块

* 用 #include < filename.h> 格式来引用标准库的头文件（编译器将从标准库目录开始搜索）

* 用 #include “filename.h” 格式来引用非标准库的头文件（编译器将从用户的工作目录开始搜索）

* 头文件中只存放“声明”而不存放“定义”

  

### 源文件结构：

* 源文件由版权和版权声明、头文件引用、函数实现等3部分组成

* 源文件的函数实现，返回值类型声明需独占一行

  

### 命名规则：

* 宏命名

  * 自定义宏采用大写字母加下划线的模式命名。

  * 普通宏，下划线不能出现在首部和尾部，常量宏可在命名空间内部定义。

     #define SOME_MACRO_DEFINITION

  * 编译宏，下划线可以出现在首部，编译宏需在命名空间外部定义。

  ​        #define _DEBUG

  

* 命名空间命名

  * 需遵循大驼峰法（命名空间常常与类名一起使用，二者均采用大驼峰法命名有助于保持代码的一致性）

  * 为了避免与其他库或应用的定义发生冲突，公共基础类库的所有 API 都嵌在 xxx 命名空间中。依据 API的功能分类不同，划分不同的子命名空间

    xxx 名称空间
    namespace xxx
    {
    namespace Log
    {
    }
    }
    
    

* 类命名

  * 标准类，类名遵循大驼峰法。

    class SystemLog

    {

    }

    

  * 接口类，需为类名增加 Interface  前缀

    class ISystemLog

    {

    }

    

  * 实现类，需为类名增加 Implementation  后缀。

    class SystemLogI

    {

    }

    所有公共基础类库 API 都由 xxx

    

  * 命名空间或其子命名空间限定，因此不用担心出现同名类的情况。为保持类名的简洁性，不建议为类名增加 Class前缀，如：建议使用 SystemLog 而不建议使用 CSystemLog 作为类名。

    

* 结构体：大驼峰法

  

* 指针类型：

  * 普通指针类型名

    NormalPointerClass* normalPointer;

  * 智能指针类型名

    SmartPointerClassPtr smartPointerPtr;

  * 对于智能指针，建议为其类型名和变量名均增加“Ptr”后缀，从而将其与普通指针类型和指针区分开来。

    

* 常量：

  * 常量采用大写字母加下划线的模式命名。

    \#define SOME_MAX_VALUE 100

    const int SOME_CONSTANT_VALUE = 0;

* 变量：

  * 命名需遵循小驼峰法。

  * 全局变量，需为变量名增加“g_”前缀。

    int g_someGlobalVariable;

  * 成员变量，需为变量名增加“_”前缀。

    int _someMemberVariable;

  * 局部变量，命名遵循小驼峰法。

    int someLocalVariable;

    之所以在为成员变量命名时不采用“m\_”前缀而仅采用“\_”前缀，也是为了保持代码的简洁性。“\_”前缀已足够区分成员变量和局部变量，而“g_”前缀也足够将全局变量与局部变量、成员变量区分开来。

    

* 函数:

  * 函数名以及函数参数名遵循小驼峰法。

    int someFunction(int someVar);

    

### 表达式和基本语句



* 复合表达式：

  * 适当添加括号以明确表达式的操作顺序

  * 防止滥用复合表达式

  * 不要编写太复杂或具有多种用途的复合表达式



* 条件表达式：

  * 在使用关系操作符的条件表达式语句中，若需比较变量与常量的关系，则应将常量写在表达式的左边，而将变量写在表达式的右边；

    ```c
     if (somePtr == NULL) // 开发人员期望输入的表达式是这样的
    
      // 不小心少输入一个"="字符，比较关系表达式变成赋值语句
    
      if (somePtr = NULL) // 编译器无法发现此问题，代码仍可正确编译（Bug 隐秘，难以发现）
    
      // 若采用下述书写方式
    
      if (NULL == somePtr) // 常量 NULL 写在左边，变量 somePtr 写在右边
    
      // 不小心少输入一个"="字符，比较关系表达式变成将变量赋值给常量的赋值语句
    
      if (NULL = somePtr) // 编译器发现此问题，代码无法正确编译（编译器直接定位 Bug）
    
    ```

    

* 布尔变量与零值比较：

  * 根据布尔类型的语义，零值为“假”（记为 FALSE），任何非零值都是“真”（记为 TRUE）。然而，TRUE 值究竟是什么并没有统一的

    标准。如 Visual C++ 将 TRUE 定义为 1，而 Visual Basic 则将 TRUE 定义为 -1。

  * 不可将布尔变量直接与TRUE、FALSE 或者1、0 进行比较；

  * 假设布尔变量 flag，它与零值比较的标准 if 语句如下

    ```c
    if (FALSE == flag)  // 不良风格
    if (0 == flag)      // 不良风格
    ```

    

* 整型变量与零值比较：

  * 应当将整型变量用 “==” 或 “!=” 直接与 0 比较：

    ``` C
    while (0 == value)
    while (0 != value) 
        
    // 不可模仿布尔变量的风格而写成
    while (value)
    while (!value) //会让人误解 value 是布尔变量

  

* 浮点变量与零值比较

  * 无论是 float 还是 double 类型的变量，都有精度限制。所以一定要避免将浮点变量用 “==” 或 “!=” 与数字比较，应该设法转化成“>=” 或 “<=” 形式。

  * 不可将浮点变量用 “==” 或 “!=” 与任何数字比较；

    ```c
    if (0.0 == x)
    // 隐含错误的比较
    // 应当将上式转化为
    if ((-EPSINON <= x) && (EPSINON >= x))   // EPSINON 是允许的误差（即精度）
    ```
    
    
  
* 指针变量与零值比较

  * 指针变量的零值是“空”（记为 NULL ）。尽管 NULL 的值与 0 相同，但是两者意义不同。

  * 应当将指针变量用 “==” 或 “!=” 与 NULL 比较；

    ```c
    if (NULL == p) // p 与 NULL 显式比较，强调 p 是指针变量
    if (NULL != p) 
    // 不要写成
    if (0 == p) // 容易让人误解 p 是整型变量
    if (0 != p)// 容易让人误解 p 是整型变量
    
    // 也不要写成
    if (p) // 容易让人误解 p 是布尔变量
    if (!p) // 容易让人误解 p 是布尔变量
    ```

    

### 循环语句

* 循环语句，特别是多重嵌套循环语句，必须关注循环语句的执行效率。提高循环语句执行效率的基本办法是降低循环语句的复杂度。
* 如果循环语句内存在逻辑判断，且循环次数较大，则应将逻辑判断移到循环语句外，以提高循环语句的执行效率；

```c
for (i=0; i<N; i++)    // 程序逻辑更简洁明了
{
    if (condition)
	    doSomething();
	else
		doOtherthing();
}
// 当 N 值比较大时，按下述方式改写后，循环语句的执行效率更高
if (condition)
{
	// 程序执行效率更高
	for (i=0; i<N; i++)
		doSomething();
}
else
{
	for (i=0; i<N; i++)
		doOtherthing();
}
```



* 不可在 for 循环体内修改循环变量，以防止 for 循环失去控制；
* 建议 for 语句的循环控制变量的取值采用“半开半闭区间”写法；

```c
for (int x=0; x<N; x++)    // 循环变量的取值属于半开半闭区间：x∈[0, N)
{
	...
}
for (int x=0; x<=N-1; x++)  // 循环变量的取值属于闭区间：x∈[0, N-1]
{
	...
}
```





###  switch 语句

* 每个 case 语句的结尾不要忘了加 break，否则将导致多个分支重叠（除非有意使多个分支重叠）；

* 若某个 case 不需要 break 一定要加注释声明，便于明白是故意不加而不是忘记；

* 不要忘记最后那个 default 分支。即使程序真的不需要 default 处理，也应该保留语句 default : break;

  

### goto 语句

* 慎用 goto 语句；







### 常量

常量是一种标识符，其值在运行期间恒定不变。C 语言用 #define 来定义常量（称为宏常量）；C++ 语言除了 #define 外还可以用 const 来定义常量（称为 const 常量）。



* const 与 #define 比较
  * C++ 语言可以用 const 来定义常量，也可以用 #define 来定义常量。但是 const 常量相比宏常量有更多的优点：const 常量有数据类型，而**宏常量没有数据类型**；
  * 编译器可以对 const 常量进行类型安全检查，而对宏常量只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。
  * 尽量使用含义直观的常量来表示那些将在程序中多次出现的数字或字符串；
  * 在 C++ 程序中只使用 const 常量而不使用宏常量，即用 const 常量取代宏常量；

​				\#define MAX 100  /* C 语言的宏常量 */

​				const int MAX = 100;  // C++ 语言的 const 常量

​				const float PI = 3.14159;  // C++ 语言的 const 常量

* 常量定义规则
  * 将需要对外公开的常量放在头文件中，将不需要对外公开的常量放在源文件的头部。为便于管理，可以把不同模块的常量集中存放在一个公共的头文件中；
  * 如果某一常量与其它常量密切相关，应在常量定义时包含这种关系，而不应给出一些孤立的值；

```c
onst float RADIUS = 100;// 半径
const float DIAMETER = RADIUS * 2;  // 直径
```



### 函数

* 函数的参数
  * 函数的参数要书写完整，不要只写参数类型而省略参数名称，如果函数没有参数，则应用 void 填充；
  
    ```c
    void setValue(int width, int height);  // 良好的风格
    void setValue(int, int);// 不良的风格
    float getValue(void);// 良好的风格
    float getValue();// 不良的风格
    ```
  
    
  
  * 如果参数是指针，且仅作输入用，则应在类型前加 const，以防止该指针在函数体内被意外修改；void stringCopy(char *strDestination，const char *strSource);
  
  * 如果输入参数以传值方式传递对象，则宜改用 “const & ”方式来传递，这样可以省去临时对象的构造和析构过程，从而提高效率；
  
  * 参数缺省值只能出现在函数声明处，而不能出现在函数定义处；
  
  * 如果函数有多个参数，带缺省值参数只能出现在不带缺省值参数的右边；
  
  * 应避免函数参数过多的情况，将参数个数控制在 5 个以内，如果需要传递的参数过多，则可考虑引入结构体参数；



* 函数的实现

  * 在函数实现的 “入口处” 对输入参数的有效性进行验证；

  * 在函数实现的 “出口处” 确保输出参数或返回值的正确性，并保证 return 语句的效率；

  * return 语句不可返回指向 “栈内存” 的 “指针” 或者 “引用”（栈内存数据在函数体结束时将被自动销毁）；

  * 要搞清楚返回的究竟是 “值”、“指针” 还是 “引用”；

  * 如果函数返回值是一个对象，则要考虑 return 语句的效率；

    ```c
    char *someFunction(void)
    {
    char str[] = "hello world";   // str 的内存位于栈上
    ...
    return str; // 将导致错误
    }
    ```

  
  * 函数的功能要单一，不要设计多用途的函数；
  
  
  * 函数体的规模要小，尽量控制在 50 行代码之内；
  
  
  * 尽量避免函数带有 “记忆” 功能，相同的输入应当产生相同的输出；带有 “记忆” 功能的函数，其行为可能是不可预测的，因为它的行为可能取决于某种“记忆状态”，这样的函数既不易理解又不利于测试和维护；
  
  
  * 在 C/C++ 语言中，函数的 static 局部变量是函数的 “记忆” 存储器，建议尽量少用 static 局部变量，除非必需；
  
  
  * 不仅要检查输入参数的有效性，还要检查通过其它途径进入函数体内变量的有效性，例如全局变量、文件句柄等；
  
  
  * 用于出错处理的返回值一定要清晰明了，让使用者不易忽视或误解错误情况；
  
    
  

### 断言的使用

断言 assert 是仅在 Debug 版本起作用的宏，它用于检查 “不应该” 发生的情况。
在运行过程中，如果 assert 的参数为假，那么程序就会中止（一般地还会出现提示对话，说明在什么地方引发了 assert）；
assert 不是一个仓促拼凑起来的宏，为了不在程序的 Debug 版本和 Release 版本引起差别，assert 不应该产生任何副作用，所以 assert 不是函数，而是宏；
程序员可以把 assert 看成一个在任何系统状态下都可以安全使用的无害测试手段，如果程序在 assert 处终止了，并不是说含有该 assert 的函数有错误，而是调用者出了差错，assert 可以帮助我们找到发生错误的原因；



* 使用断言捕捉不应该发生的非法情况（不要混淆非法情况与错误情况之间的区别，后者是必然存在的并且是一定要作出处理的）；

* 在函数的入口处，使用断言检查参数的有效性（合法性）；

* 在编写函数实现时，要反复考查并且问自己打算做哪些假定？一旦确定了的假定，就要使用断言对假定进行检查；

  

### 引用与指针的区别

* 引用被创建的同时必须被初始化，而指针则可以在任何时候被初始化；

* 不能有 NULL 引用，引用必须与合法的存储单元关联，而指针则可以是 NULL；

* 一旦引用被初始化，就不能改变引用的关系，而指针则可以随时改变所指的对象；



### 内存管理

#### 内存分配

* C/C++ 内存分配方式有三种：

  * 从静态存储区域分配，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在（如：全局变量、static变量）；

  * 在栈上创建，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放，栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限；

  * 从堆上分配，亦称动态内存分配，程序在运行的时候用 malloc 或 new 申请任意大小的内存，程序员自己负责在何时用 free或 delete 释放内存，动态内存的生存期由程序员决定，使用非常灵活，但问题也最多；



* 用 new、delete 取代 malloc、calloc、realloc 和 free（malloc、calloc、realloc 和 free 是 C语言的用法，它们不会意识到对象的存在与否，也不会去调用构造和析构函数）；

  * 不能混用 new 和 free、malloc 和 delete；

  * 动态内存的申请与释放必须配对，即 new、delete 和 new[]、delete[] 要成对使用，不需要的内存应被及时释放，要注意防止内存泄漏 ；

  * 申请内存之后，应该立即检查指针值是否为 NULL，防止使用指针值为 NULL 的内存；

  * 释放了内存之后，立即将指针设置为 NULL，防止产生 “野指针”，除非该指针变量本身将要消亡；

* 不要忘记为数组和动态内存赋初值，防止将未被初始化的内存作为右值使用；

  * 避免数组或指针的下标越界，特别要当心发生 “多1” 或者 “少1” 操作；

  * 当对象消亡时确保指针成员指向的系统堆内存全部被释放，否则会造成内存泄露；

#### 内存释放

* C/C++中对内存使用的基本原则是 “谁申请，谁释放”。但在很多实现中经常会出现一些 “隐式分配内存”、“异地分配内存”的情况：

  * 隐式内存分配，在这里定义为这样一种情况，对象 A 调用 对象 B 的方法来获取一些数据或者进行一些数据操作，在这个过程中，对象B 的方法内部可能会发生内存的分配，但在 对象 A 使用这片内存之前，不应该释放这片内存；
    * 方案1，被调用者隐式分配了内存，调用者需要显式去释放内存（使用delete函数）
    * 方案2，被调用者通过回调方式将数据返回给调用者，回调完毕之后，由被调用者主动释放
    * 方案3，被调用者的函数提供二次调用的方法，调用者第一次先调用该函数获取需要分配的内存大小，然后分配内存之后再次调用函数。这样在使用完该内存片之后，调用者可以主动释放内存

  * 同一片内存可能会被多个使用者使用，那么应该在什么时候释放内存呢？为对象 A 管理的这片内存增加引用计数，当计数为 0 的时候由对象 A 进行释放



### 类

#### 构造函数

* “缺省的拷贝构造函数” 和 “缺省的赋值函数” 均采用 “位拷贝” 而非 “值拷贝”的方式来实现，若类中含有指针变量，不能采用缺省的方式；

* 如果类存在继承关系，派生类必须在其初始化表里调用基类的构造函数；

* 类的 const 常量只能在初始化表里被初始化，因为它不能在函数体内用赋值的方式来初始化；

* 拷贝构造函数和赋值函数非常容易混淆，拷贝构造函数是在对象被创建时调用的，而赋值函数只能被已经存在了的对象调用；

* 非内部数据类型的成员对象采用初始化表的方式初始化较好；

  

#### 成员函数

* 任何不会修改数据成员的函数都应该声明为 const 类型；

  

#### 继承与组合

* 对于 C++ 程序而言，设计孤立的类是比较容易的，难的是正确设计基类及其派生类。

* 如果类 A 和类 B 毫不相关，不能为了使 B 的功能更多些而让 B 继承 A 的功能和属性；

* 若在逻辑上 B 是 A 的 “一种情况”，则允许 B 继承 A 的功能和属性；

* 若在逻辑上 A 是 B 的 “一部分”（a part of），则不允许 B 从 A 派生，而是要用 A 和其它东西组合出 B；

  

### 其他

* 程序的效率

  程序的时间效率是指运行速度，空间效率是指程序占用内存或者外部存储空间的状况。全局效率是指站在整个系统的角度上考虑的效率，局部效率是指站在模块或函数角度上考虑的效率。

  * 不要一味地追求程序的效率，应当在满足正确性、可靠性、健壮性、可读性等质量因素的前提下，设法提高程序的效率；

  * 以提高程序的全局效率为主，提高局部效率为辅；
  * 在优化程序的效率时，应当先找出限制效率的  “瓶颈”，不要在无关紧要之处优化；
  * 先优化数据结构和算法，再优化执行代码；
  * 有时候时间效率和空间效率可能对立，此时应当分析哪个更重要，作出适当的折衷（如多花费一些内存来提高性能）；
  * 不要追求紧凑的代码，因为紧凑的代码并不能产生高效的机器码；
